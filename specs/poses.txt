# Implementation of pose reader/writer as defined in the architecture document

A. Simulation of poses
Stage A is to simulate a reasonably realistic set of poses. This is done as part of  test_poses.py, and goes as follows.
Load the AA library and select the second nucleotide (use library.py).
Select twenty conformers R1 #1-#5 from the library. For each conformer, select one random rotamer. Verify that it's center-of-mass (COM) is within 3 angstroms (units) from the COM of the rotamer chosen for conformer #1. Store the rotamer rotation matrices and the COMs.
Then, unload the rotamers for the AA library and load the AC library, and select the first nucleotide.
For each conformer conf1:
    - Select ten compatible conformers conf2 from the AC library. A compatible conformer is defined as having an RMSD lower than 0.5 A after superposition (use superimpose.py) .
    For each conformer conf2:
        - Select ten random rotamers R2 #1-#10. For rotamer #2-#10, verify that it's COM is within 3 angstroms (units) from the COM of rotamer #1. Store the ten rotamer rotation matrices and the ten COMs.
There are now 20 x 1 x 10 x 10 combinations of conf1, R1, conf2 and R2.
For every combination:
    - determine the displacement vector that is the difference between the COM of conf1-R1 and the COM of conf2-R2.
    - Select a radius at random between -0.2 and 1.2. Divide this radius by sqrt(3)/3.
Using all displacement vectors and radii, obtain the translations for each combination using offsets.py. These translations are stored in three forms: 1. as the output of get_discrete_offsets; 2. as a list of lists generated by expand_discrete_offsets; 3. as two arrays indices + data as generated by gather_discrete_offsets.

B. Implementation and round-trip test
Add to test_poses an invocation of the function pack_all_poses from poses.py. This function takes as input an array of conformer indices, an array of rotamer indices, and a 4-tuple corresponding to the output of get_discrete_offsets. All inputs must have the same length.
As an output, it returns a list of 3-tuple. Each 3-tuple corresponds to:
    - poses (corresponding to poses.npy as defined in architecture.txt)
    - mean_offset (corresponding to the three int16 values that are the first six bytes of poses.dat)
    - offsets (the (X, 3) uint8 array of poses.dat after the first six bytes)
As mentioned in architecture.txt, there may be multiple poses.npy + offset.dat, which
will each be a 3-tuple in the list. In case of the test, the list must have a length of one.
Then, the test invoked the function unpack_poses from poses.py. This function takes the arguments of a single 3-tuple of the list, i.e. it is invoked on the first 3-tuple in this case. The output of unpack_poses is array of conformer indices, an array of rotamer indices, and an array of index-headed translations as generated by gather_discrete_offsets. It is verified that the first two arrays are identical to the first two arrays that were given to pack_all_poses, and that the last array is equal to form 3. of the simulated translations.
The functions pack_all_poses and unpack_poses will be implemented, and tested using the round trip test until it succeeds.
