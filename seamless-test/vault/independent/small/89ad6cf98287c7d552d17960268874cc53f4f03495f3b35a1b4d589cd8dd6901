{
  "code": "import numpy as np, sys\n\nfrom scipy.spatial.transform import Rotation\n\ndef get_structure_tensor(struc):\n    struc0 = struc - struc.mean(axis=0)\n    v, s, wt = np.linalg.svd(struc0) \n    scalevec = s/np.sqrt(len(struc))\n    tensor = wt.T\n    if np.linalg.det(tensor) < 0:\n        tensor[2] *= -1\n    assert np.linalg.det(tensor) > 0.999\n    return tensor, scalevec\n\n\ndef get_msd(mats, refe, scalevec):\n    if refe is None:\n        rrmats = mats\n    else:\n        rrmats = np.einsum(\"ikl,ml->ikm\",mats, refe)\n        # broadcasted form of mats[i].dot(refe.T)\n\n    rr = Rotation.from_matrix(rrmats)\n    ax =  rr.as_rotvec()\n    ang = np.linalg.norm(ax,axis=1)\n    ax /= ang[:, None]\n    fac = (np.cos(ang)-1)**2+np.sin(ang)**2\n    cross = (scalevec * scalevec) * (1 - ax*ax)\n    msd = fac * cross.sum(axis=-1)\n    return msd\n\ndef clusterize(matrices, scalevec, rmsd):\n    cluster_storage = np.zeros((1000,3,3))\n    clusters = cluster_storage[:1]\n    clusters[0] = matrices[0]\n    curr = matrices[1:]\n    cluspos = 0\n    while len(curr):\n        msd = get_msd(curr, clusters[cluspos], scalevec)   \n        curr = curr[msd>(rmsd*rmsd)]\n        cluspos += 1\n        if cluspos == len(clusters):\n            if not len(curr):\n                break\n            if len(clusters) == len(cluster_storage):\n                new_cluster_storage = np.zeros((int(1.1*len(cluster_storage)), 3, 3))\n                new_cluster_storage[:len(cluster_storage)] = cluster_storage\n                cluster_storage = new_cluster_storage\n            cluster_storage[len(clusters)] = curr[0]\n            clusters = cluster_storage[:len(clusters)+1]\n            curr = curr[1:] \n    return clusters\n\nif __name__ == \"__main__\":\n    import argparse\n    np.random.seed(0)\n    parser =argparse.ArgumentParser()\n    parser.add_argument(\"infile\", help=\"Molecule as Mx3 coordinates\")\n    parser.add_argument(\n        \"outfile\",\n        help=\"Rotations as array of Cx3x3 rotation matrices, where C is the number of rotamers\"\n    )\n    parser.add_argument(\"--nstruc\",type=int,help=\"Number of random orientations to sample and cluster\",required=True)\n    parser.add_argument(\"--rmsd\",type=float,help=\"RMSD threshold for clustering\",required=True)\n    args = parser.parse_args()\n\n    struc = np.load(args.infile)\n    struc -= struc.mean(axis=0)\n\n    v, s, wt = np.linalg.svd(struc)\n    scale = s/np.sqrt(len(struc))\n    strucp = struc.dot(wt.T)  \n    r = Rotation.random(args.nstruc)\n    rmat = r.as_matrix()\n    chunksize = 2000\n\n    cluster_storage = np.zeros((1000,3,3))\n    clusters = cluster_storage[:1]\n    clusters[0] = rmat[0]\n    thresholdsq = args.rmsd**2\n    for n in range(1, args.nstruc, chunksize):\n        chunk = rmat[n:n+chunksize]        \n        cluspos = 0\n        print(n,len(clusters))\n        while 1:\n            #print(n,len(chunk), cluspos, len(clusters))\n            rrmat = np.einsum(\"ikl,ml->ikm\",chunk, clusters[cluspos])\n            # broadcasted form of chunk[i].dot(clusters[cluspos].T)\n\n            rr = Rotation.from_matrix(rrmat)\n            ax =  rr.as_rotvec()\n            ang = np.linalg.norm(ax,axis=1)\n            ax /= ang[:, None]\n            fac = (np.cos(ang)-1)**2+np.sin(ang)**2\n            cross = (scale * scale) * (1 - ax*ax)\n            msd = fac * cross.sum(axis=-1)\n        \n            chunk = chunk[msd>thresholdsq]\n            cluspos += 1\n            if cluspos == len(clusters):\n                if not len(chunk):\n                    break\n                if len(clusters) == len(cluster_storage):\n                    new_cluster_storage = np.zeros((int(1.1*len(cluster_storage)), 3, 3))\n                    new_cluster_storage[:len(cluster_storage)] = cluster_storage\n                    cluster_storage = new_cluster_storage\n                cluster_storage[len(clusters)] = chunk[0]\n                clusters = cluster_storage[:len(clusters)+1]\n                chunk = chunk[1:] \n    \n \n    np.save(args.outfile, clusters)",
  "language": "python",
  "type": "interpreted"
}
