{
  "code": "import numpy as np\nfrom rotamers import get_msd, get_structure_tensor, clusterize\nfrom scipy.spatial.transform import Rotation\nimport itertools\n\ndef estimate_nclust_curve(rmsd, scalevec,  r1size, r2size):\n    r1 = Rotation.random(r1size).as_matrix()\n    r2 = Rotation.random(r2size).as_matrix()\n    result = {}\n    for r_rmsd in np.arange(rmsd, max(scalevec), 0.5):\n        clusters = clusterize(r1, scalevec, r_rmsd)\n        cov = 0\n        for rr2 in r2:\n            rr2_msd = get_msd(clusters, rr2, scalevec)\n            if rr2_msd.min() < (r_rmsd * r_rmsd):\n                cov += 1\n        coverage = cov / len(r2)\n        est_size = len(clusters)/coverage\n        print(r_rmsd, len(clusters), coverage, est_size)\n        result[r_rmsd] = est_size\n    return result\n\ndef estimate_rmsd_dist(rmsds, scalevec, rsize):\n    r = Rotation.random(rsize).as_matrix()\n    dist = {}\n    comb = list(itertools.product(rmsds, repeat=2)) \n    comb = np.array(comb)\n    comb_rmsds = set(list(comb.sum(axis=1))+ list(rmsds))\n    msds = get_msd(r, None, scalevec)\n    for rmsd in comb_rmsds:\n        count = (msds<(rmsd*rmsd)).sum()\n        dist[rmsd] = count/len(msds)\n    return dist\n\ndef get_best_clustering_hierarchy(est_size, rmsd_dist, rmsd, max_cost_frac):\n    \"\"\"\n    At each RMSD r, we have an estimate of:\n    - The absolute size S(r) of the total number of clusters \n    - The distribution D(r), describing \n        which percentage of RMSDs between random rotations is within r\n\n    Now we compare:\n    - Direct clustering at r1\n    - Hierarchical clustering at r2, then evaluating the members of\n       relevant clusters at r1\n    \n    For direct clustering, we evaluate against existing clusters at r1.\n    Let's call this cost C.\n\n    For the first step of hierarchical clustering, we evaluate against\n    existing clusters at r2 instead of r1. There are fewer of those. \n    The cost of the first step is then S(r2)/S(r1) * C\n\n    For the second step, we need to select relevant clusters. These are\n    the ones where the RMSD < r1 + r2, i.e. D(r1+r2) .\n    Only this fraction of the existing r1 clusters we evaluate,\n      the others (1 - D(r1+r2)) we skip\n    The cost of the second step is then D(r1+r2) * C\n\n    The total cost fraction is thus S(r2)/S(r1) + D(r1+r2)\n\n    For the next level of hierarchical clustering,\n    we choose r3 so that we can identify the relevant members of r2\n    relevant members are in fact those within r1+r2 RMSD.\n    So here, the cost fraction becomes S(r3)/S(r2) + D(r1+r2+r3)\n\n    If the cost fraction is less than 1, we save time\n    In practice, use the max_cost_frac. Hierarchy costs overhead too!\n    In addition, since we cluster top down, \n      some r2 clusters would be split up by r3 clustering. \n    \"\"\"\n\n    r1 = rmsd\n    hierarchy = [r1]\n    sumr = r1\n    while 1:\n        for r2 in sorted(est_size)[1:]:\n            if r2 <= r1:\n                continue\n            if sumr+r2 not in rmsd_dist:\n                continue\n            cost = est_size[r2]/est_size[r1] + rmsd_dist[sumr+r2]\n            #print(r1, r2, cost)\n            if cost < max_cost_frac:                \n                r1 = r2\n                sumr += r1\n                hierarchy.append(r1)\n                break\n        else:\n            break\n    return hierarchy\n\n\ndef build_rotamers(struc, rmsd):\n    import build_rotamer_lib\n\n    struc -= struc.mean(axis=0)\n    \n    # Get structure tensor\n    tensor, scalevec = get_structure_tensor(struc)\n    \n    r1size, r2size = 1000, 5000\n    ### est_size = estimate_nclust_curve(rmsd, scalevec, r1size, r2size) ###\n    ###\n\n    r3size = 5000000\n    ### rmsd_dist = estimate_rmsd_dist(list(est_size.keys()), scalevec, r3size)\n\n    #for r in sorted(rmsd_dist):\n    #    print(r, est_size.get(r), rmsd_dist[r])\n    \n    ### hierarchy = get_best_clustering_hierarchy(est_size, rmsd_dist, rmsd, 0.3)\n    hierarchy = [1.0, 2.0, 3.5, 6.5]\n    ###\n\n    print(hierarchy)\n \n    r4 = 300000 # TODO: compute\n    r4 = 500 ###\n    np.random.seed(0)\n    r = Rotation.random(r4)\n    #print(r[0].as_matrix())\n    return build_rotamer_lib.build_rotamers(r.as_matrix(), scalevec, hierarchy)\n\nif __name__ == \"__main__\": \n    import argparse\n    np.random.seed(0)\n    parser =argparse.ArgumentParser()\n    parser.add_argument(\"infile\", help=\"Molecule as Mx3 coordinates\")\n    parser.add_argument(\n        \"outfile\",\n        help=\"Rotations as array of Cx3x3 rotation matrices, where C is the number of rotamers\"\n    )\n    parser.add_argument(\"--rmsd\",type=float,help=\"RMSD threshold for clustering\",required=True)\n    args = parser.parse_args()\n\n    struc = np.load(args.infile)\n    rotamers = build_rotamers(struc, args.rmsd)\n    np.save(args.outfile, rotamers)",
  "dependencies": [
    "rotamers"
  ],
  "language": "python",
  "type": "interpreted"
}
